<h1>Registers</h1>
<pre class="metadata">
Repository: openregister/specification
Logo: https://assets.digital.cabinet-office.gov.uk/static/images/gov.uk_logotype_crown.png
Status: LS-COMMIT
ED: https://openregister.github.io/specification/
Shortname: registers
Level: 1
Editor: Arnau Siches, Government Digital Service, arnau.siches@digital.cabinet-office.gov.uk
Editor: Michaela Benyohai, Government Digital Service, michaela.benyohai@digital.cabinet-office.gov.uk
Former Editor: Paul Downey, Government Digital Service
Former Editor: Daniel Appelquist, Government Digital Service
Group: registers
Indent: 2
Inline Github Issues: false
Abstract:
  This document defines the resources and representations which together
  provide an Application Programming Interface (API) for accessing 
  data held in a register.

Version History: https://github.com/openregister/specification/commits/gh-pages/index.bs
!Bug Reports: <a href="[REPOSITORYURL]/issues">via the openregister/specification repository on GitHub</a>
</pre>

<pre class=include>
path: include/logo-openregister.include
</pre>

<pre class=include>
path: include/copyright-openregister.include
</pre>

<style>
  svg.railroad-diagram { width: 100%; }

  dt {
    font-weight: bold;
    font-style: italic;
    color: #005A9C;
  }

  dl.resource {
    background: #DEF;
    border-left: 0.5em solid #8CCBF2;
  }
  dl.resource dt {
    display: inline-block;
    min-width: 100px;
    padding: 0.5em;
    font-style: normal;
    font-weight: normal;
    text-transform: uppercase;
  }
  dl.resource dd {
    display: inline;
    margin: 0;
  }
  dl.resource dd:after{
    display: block;
    content: '';
  }
  dl.resource a {
    color: #005A9C;
    padding: 0 0.25em;
  }
</style>

# Introduction # {#introduction}

<em>An introduction to the product, independent of HMG's use of registers ..</em>

# Infoset # {#infoset}

Note: Data items in this specification are defined in terms of an information set which can be mapped to one of a number of different representations. There is no canonical representation.

* An infoset is an unordered collection of data items.
* A data item is identified within the scope of the infoset by a [[#field-field]] value.
* The contents of a data item is constrained by one of a number of different [[#datatypes]].

ISSUE(openregister/specification#40): possible confusion: "data item" and "item" mean different things

# Entity resources # {#entity-resources}

## Item resource ## {#item-resource}

<dl class="resource"><dt>Path</dt><dd>/item/{<a href="#item-hash-field">item-hash</a>}</dd></dt></dl>

An item is an unordered collection of [[#fields]] and values.
The set of fields which MAY be included in an item are defined in the 
[[#fields-field]] field in the [[#register-register]] entry for the register.

An item is identified by the globally unique [[#item-hash-field]]
calculated from its contents. Changing the item data changes the [[#item-hash-field]].

<div class="example">
The following example shows an item in the [[#json-representation]]:
<pre>
https://food-premises.register.gov.uk/item/sha-256:bdc7f29f7d2ef36f9db1ec7b4141286288a1bd79254d59b46f3a8baa3484f858
</pre>
<pre highlight="json">
{
  "business": "company:07228130",
  "food-premises": "788112",
  "food-premises-types": ["restaurant", "cafe"],
  "local-authority": "E09000015",
  "name": "Roy's Rolls",
  "premises": "13456079000",
  "start-date": "2015-03-01"
}
</pre>
</div>

## Entry resource ## {#entry-resource}

<dl class="resource"><dt>Path</dt><dd>/entry/{<a href="#entry-number-field">entry-number</a>}</dd></dt></dl>

An entry is an update to a register.  The register as a whole is made
up of an ordered list of entries.  New entries in a register are only
ever appended to the end of the list; once an entry is created, it
never gets changed.

An entry is an [[#entry-number-field]], an [[#index-entry-number-field]], a timestamp, an
[[#item-hash-field]] and a [[#key-field]].  The entry-number is unique and defines the
entry's position within the ordered list of a register. The index-entry-number is unique
and defines the entry's position within the ordered list of an index. For an entry in a register
the entry-number and index-entry-number are always identical. The item-hash identifies
the set of [[#item-resource]] for the entry. The key represents the primary key value
for the entry.

The entry resource returns an array containing a single entry.

<div class="example">
The following example shows an entry in the [[#json-representation]]:

<assert>
<pre highlight="json">
[
  {
    "index-entry-number": "72",
    "entry-number": "72",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "key": "402019",
    "item-hash": [
        "sha-256:d9178efd8febfebaaa42968648b7bdd023369c7f"
    ]
  }
]
</pre>
</assert>
</div>

ISSUE(openregister/specification#48): Entry timestamp semantics are not defined.

ISSUE(openregister/specification#50): Hypermedia link from entry to item?

## Record resource ## {#record-resource}

<dl class="resource"><dt>Path</dt><dd>/record/{<a href="#field-value">field-value</a>}</dd></dt></dl>

A record is the most up-to-date [[#infoset]] for a resource identified
by a [[#primary-key-field]].  That is, it is the infoset corresponding
to the [[#entry-resource]] with the highest [[#entry-number-field]]
for a given primary key value.

This resource is provided as a convenience: in principle, it can be
computed by a client by replaying the log of all entries and finding
the latest one with the given primary key value.

This resource SHOULD provide a Link: header [[RFC5988]] with a
relation of <code>"version-history"</code> [[RFC5829]] to the
[[#record-entries-resource]] for this record.

<div class="example">
The following example shows a record in the [[#json-representation]]:

<pre highlight="json">
https://local-authority.register.gov.uk/record/E09000019
{
  "E09000019": {
    "index-entry-number": "72",
    "entry-number": "72",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "key": "E09000019",
    "item": [
        {
          "local-authority": "E09000019",
          "name": "Islington"
        }
    ]
  }
}
</pre>
</div>


## Register resource ## {#register-resource}

<dl class="resource"><dt>Path</dt><dd>/register</dd></dt></dl>

The register resource is [[#infoset]] with the following fields:

  : [[#domain-field]]
  :: The Internet domain the register is available from.
  : [[#last-updated-field]]
  :: The date the register was last updated.

The register resource also contains the following data items:

  : register-record
  :: A copy of the [[#register-register]] [[#record-resource]] entity describing this register.
  : total-items
  :: An [[#integer-datatype]] value representing the number of [[#item-resource]] entities currently stored in the register.
  : total-entries
  :: An [[#integer-datatype]] value representing the number of [[#entry-resource]] entities currently stored in the register.
  : total-records
  :: An [[#integer-datatype]] value representing the number of [[#record-resource]] entities currently stored in the register.


<div class="example">
The following example shows a register in the [[#json-representation]]:

<pre highlight="json">
{
  "domain": ".register.gov.uk",
  "last-updated": "2016-01-21T21:09:59Z",
  "register-record": {
    "entry-number": "12",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "item-hash": "sha-256:d9178efd8febfebaaa42968648b7bdd023369c7f",
    "fields": [ "address", "end-date", "school", "start-date", "name", "website" ],
    "name": "Schools in the UK",
    "phase": "beta",
    "register": "school",
    "registry": "department-of-education",
    "start-date": "2012-01-01"
  },
  "total-entries": "109001",
  "total-items": "109009",
  "total-records": "30522"
}
</pre>
</div>

## Register proof resource ## {#register-proof-resource}
<dl class="resource"><dt>Path</dt><dd>/proof/register/{proof-identifier}</dd></dt></dl>

A register proof is a digitally-signed demonstration of the integrity of all of the entries in a register.  Given a register proof, it is possible to verify that all of the entries and items are correct, and that the entries are in the correct order.

There may be different kinds of register proof available.  The exact structure of the proof will depend on the proof algorithm in use.  The algorithm is identified by a proof-identifier.  The [[#proofs-resource]] indicates which proofs are available.

<div class="example">
The following example shows a Merkle-tree-based register proof in the [[#json-representation]]:

<pre>
https://school.register.gov.uk/proof/register/merkle:sha-256
</pre>
<pre highlight="json">
{
  "proof-identifier": "merkle:sha-256",
  "total-entries": "9803348",
  "timestamp": "2015-08-20T08:15:30Z",
  "root-hash": "sha-256:JATHxRF5gczvNPP1S1WuhD8jSx2bl-WoTt8bIE3YKvU",
  "tree-head-signature":
  "BAMARzBFAiEAkKM3aRUBKhShdCyrGLdd8lYBV52FLrwqjHa5/YuzK7ECIFTlRmNuKLqbVQv0QS8nq0pAUwgbilKOR5piBAIC8LpS"
}
</pre>
</div>

## Entry proof resource ## {#entry-proof-resource}
<dl class="resource"><dt>Path</dt><dd>/proof/entry/{<a href="#entry-number-field">entry-number</a>}/{total-entries}/{proof-identifier}</dd></dt></dl>

An entry proof is the information required to prove the integrity of a single entry within a register of size total-entries, given a [[#register-proof-resource]].

The important characteristic of an entry proof is that it means the client does not need to download the entire register just to verify the integrity of a single entry.

There may be different kinds of entry proof available.

<div class="example">
The following example shows a Merkle-tree-based entry proof in the [[#json-representation]]:

<pre>
https://school.register.gov.uk/proof/entry/123/130/merkle:sha-256
</pre>
<pre highlight="json">
{
  "proof-identifier": "merkle:sha-256",
  "entry-number": "123",
  "merkle-audit-path": [ "sha-256:zWJuGh1KFSTHoI1zo0gBm9mRMeCrb8nTQdnAgT3llO8=", "sha-256:e2vgurA5X7wd9dtGXNvVRl9y2ICDIRpx3bf4ucb2wbY=" ]
}
</pre>
</div>

## Consistency proof resource ## {#consistency-proof-resource}
<dl class="resource"><dt>Path</dt><dd>/proof/consistency/{total-entries-1}/{total-entries-2}/{proof-identifier}</dd></dl>

A consistency proof proves the append-only property of a register.

The consistency proof for a register containing total-entries-2 entries and a previous version of the same register containing total-entries-1 entries (total-entries-2 > total-entries-1) is the information required to prove that the first total-entries-1 entries are equal for both, given a [[#register-proof-resource]] for each version of the register.

The important characteristic of a consistency proof between two versions of a register is that the client does not need to download the entirety of either to verify consistency between the two.

There may be different kinds of consistency proof available.

<div class="example">
The following example shows a Merkle-tree-based consistency proof in the [[#json-representation]]:

<pre>
https://school.register.gov.uk/proof/consistency/1234/1240/merkle:sha-256
</pre>
<pre highlight="json">
{
  "proof-identifier": "merkle:sha-256",
  "merkle-consistency-nodes": [ "sha-256:MAzvw8AsFqZ8Scuc5IPfj0dzl44jJauaNXuZLQxR3bM=", "sha-256:TX/kGqrSEgHGvxLwSMyX5al14G48HyPmKbUYK0+wSCE=" ]
}
</pre>
</div>

## Records proof resource ## {#records-proof-resource}

<dl class="resource"><dt>Path</dt><dd>/proof/records/{proof-identifier}</dd></dt></dl>

A records proof is a digitally-signed demonstration of the integrity of all the records in a register, given a [[#register-proof-resource]]. Given a records proof, it is possible to verify that all the entries and items that make up the records in a register are correct.

There may be different kinds of records proof available.

<div class="example">
The following example shows a Merkle-tree-based records proof in the [[#json-representation]]:

<pre>
https://local-authority.register.gov.uk/proof/records/merkle:sha-256
</pre>
<pre highlight="json">
{
  "proof-identifier": "merkle:sha-256",
  "root-hash": "sha-256:h/gTTXO9M9KARSc35nWMY1zrkISUrQYjF2ZowZgGNQg=",
  "register-proof": {
    "total-entries": "9803348",
    "timestamp": "2015-08-20T08:15:30Z",
    "root-hash": "sha-256:JATHxRF5gczvNPP1S1WuhD8jSx2bl-WoTt8bIE3YKvU",
    "tree-head-signature": "BAMARzBFAiEAkKM3aRUBKhShdCyrGLdd8lYBV52FLrwqjHa5/YuzK7ECIFTlRmNuKLqbVQv0QS8nq0pAUwgbilKOR5piBAIC8LpS"
  },
  "tree-head-signature": "YuzK7ECIFTlRmNuKLqbVQv0QS8nq0pAUwgbilKOR5piBAIC8LpS/BAMARzBFAiEAkKM3aRUBKhShdCyrGLdd8lYBV52FLrwqjHa5"
}
</pre>
</div>

ISSUE(openregister/specification#46): Records proof resource is experimental.

## Record proof resource ## {#record-proof-resource}
<dl class="resource"><dt>Path</dt><dd>/proof/record/{total-entries}/{<a href="#field-value">field-value</a>}/{proof-identifier}</dd></dl>

A record proof is the information required to prove that a particular entry is the most recent entry for a record in a register of size total-entries, given a [[#records-proof-resource]].

The important characteristic of a record proof is that it means that the client does not need to download the entire register just to verify that an entry is the latest for a record.

There may different kinds of record proof available.

<div class="example">
The following example shows a Merkle-tree-based record proof in the [[#json-representation]]. This particular proof algorithm would return an array of 256 Merkle tree nodes:

<pre>
https://local-authority.register.gov.uk/record/E09000019/merkle:sha-256
</pre>
<pre highlight="json">
{
  "proof-identifier": "merkle:sha-256",
  "merkle-record-path": ["sha-256:GRt2OZyET3cslEaq1Mme/KJ46hsmk5dV2o6utknQwtY=", "sha-256:3+8RvKuH5nhFLzQr6jFzt8jaH2Fp+rBqhbfSsPVWtcw=", "sha-256:3KN32Lo6Z3eCaisbhL4OB4O0XyLuPW37Zj23nzN/h9g=", ...]
}
</pre>
</div>

ISSUE(openregister/specification#46): Record proof resource is experimental.

# Immutable resources # {#immutable-resources}

An immutable resource, is one whose contents will never change.
An instance of an [[#item-resource]] and an [[#entry-resource]] are both deemed to be immutable.

# Collection resources # {#list-resources}

There is a limit to how many records or entries can be returned in a single request. To fetch more, pagination is used. Pagination is supported through an http link header [[RFC5988]], with a link rel="next" for the next page, and rel="previous" for the previous page. On the first page, there is no "previous" link, and on the last page there is no "next" link.

ISSUE(openregister/specification#7): define query string parameters ..

ISSUE(openregister/specification#8): if /records and /items are sets, what does that mean for pagination?

## Items resource ## {#items-resource}

<dl class="resource"><dt>Path</dt><dd>/items</dd></dt></dl>

<div class="example">
The following example shows a set of records in the [[#json-representation]]:

<pre highlight="json">
{
  "sha-256:1a0212ba5094383bcc2a0bbe1a55e3a1f1278984": {
    "local-authority": "E09000019",
    "name": "Islington"
  },
  "sha-256:d9178efd8febfebaaa42968648b7bdd023369c7f": {
    "local-authority": "E09000016",
    "name": "Havering"
  }
}
</pre>
</div>

ISSUE(openregister/specification#38): what does the items resource look like in a register with multiple hashing algorithms available?

## Entries resource ## {#entries-resource}

<dl class="resource"><dt>Path</dt><dd>/entries</dd></dt></dl>

The entries resource returns the ordered list of all [[#entry-resource]]s
ordered by entry number in ascending order.

<div class="example">
The following example shows a list of entries in the [[#json-representation]]:

<pre highlight="json">
[
  {
    "index-entry-number": "1",
    "entry-number": "1",
    "entry-timestamp": "2015-08-15T08:15:30Z",
    "key": "402019",
    "item-hash": [ 
        "sha-256:1a0212ba5094383bcc2a0bbe1a55e3a1f1278984"
    ]
  },
  {
    "index-entry-number": "2",
    "entry-number": "2",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "key": "402020",
    "item-hash": [
        "sha-256:13f6de75b9f6d970691985e72a7dfa211bad1591"
    ]
  },
  {
    "index-entry-number": "3",
    "entry-number": "3",
    "entry-timestamp": "2015-08-21T00:00:00Z",
    "key": "402020",
    "item-hash": [
        "sha-256:13f6de75b9f6d970691985e72a7dfa211ba00000"
    ]
  }
]
</pre>
</div>


## Record entries resource ## {#record-entries-resource}

<dl class="resource"><dt>Path</dt><dd>/record/{<a href="#field-value">field-value</a>}/entries</dd></dt></dl>

All of the entries which have the given [[#primary-key-field]] value, in order of [[#entry-number-field]].

<div class="example">
The following example shows a list of item entries in the [[#json-representation]]:

<pre highlight="json">
[
  {
    "index-entry-number": "121",
    "entry-number": "121",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "key": "33010",
    "item-hash": [
        "sha-256:c8844f3961a9a90812b8992ad8dbd5495e0f4782"
    ]
  },
  {
    "index-entry-number": "133",
    "entry-number": "133",
    "entry-timestamp": "2015-08-15T08:15:30Z",
    "key": "33010",
    "item-hash": [
        "sha-256:13f6de75b9f6d970691985e72a7dfa211bad1591"
    ]
  }
]
</pre>
</div>


## Records resource ## {#records-resource}

<dl class="resource"><dt>Path</dt><dd>/records</dd></dt></dl>

All [[#record-resource]]s in a register.

<div class="example">
The following example shows a list of records in the [[#json-representation]]:

<pre highlight="json">
{
  "E09000019": {
    "index-entry-number": "72",
    "entry-number": "72",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "key": "E09000019",
    "item": [
        {
          "local-authority": "E09000019",
          "name": "Islington"
        }
    ]
  },
  "E09000016": {
    "index-entry-number": "76",
    "entry-number": "76",
    "entry-timestamp": "2015-08-20T08:15:30Z",
    "key": "E09000016",
    "item": [
        {
          "local-authority": "E09000016",
          "name": "Havering"
        }
    ]
  }
}
</pre>
</div>

## Faceted records resource ## {#faceted-records-resource}

<dl class="resource"><dt>Path</dt><dd>/records/{<a href="#field-field"">field-name</a>}/{<a href="#field-value"">field-value</a>}</dd></dt></dl>

All [[#record-resource]]s in a register which have the same value in the given field.

<div class="example">
The following example shows a list of record entries matching a field in the [[#json-representation]]:

<pre highlight="http">
https://school.register.gov.uk/records/religious-character/Quaker.json
</pre>
<pre highlight="json">
{
  "123278": {
    "index-entry-number": "18371",
    "entry-number": "18371",
    "entry-timestamp": "2016-01-01T00:00:00Z",
    "item": [
        {
          "address": "10011891998",
          "maximum-age": "18",
          "minimum-age": "2",
          "name": "Sibford School",
          "religious-character": "Quaker",
          "school": "123278",
          "start-date": "1945-01-01",
          "website": "http://www.sibford.oxon.sch.uk"
        }
    ]
  },
  "121728": {
    "index-entry-number": "17164",
    "entry-number": "17164",
    "entry-timestamp": "2016-01-01T00:00:00Z",
    "item": [
        {
          "address": "200004778207",
          "end-date": "2006-02-28",
          "headteacher": "Mrs S Ratcliffe",
          "name": "Boothan Junior School",
          "religious-character": "Quaker",
          "school": "121728",
          "start-date": "1957-10-21",
          "website": "http://www.bootham.york.sch.uk/ebor"
        }
    ]
  }
}
</pre>
</div>

## Proofs resource ## {#proofs-resource}

<dl class="resource"><dt>Path</dt><dd>/proofs</dd></dt></dl>

All of the available proof algorithms that the register supports.

<div class="example">
The following example shows a set of register proofs in the [[#json-representation]]:

<pre highlight="json">
['merkle:sha-256']
</pre>
</div>

Note: A register MAY have more than one proof, to support multiple types of proof in the future.

## Entry proof nodes resource ## {#entry-proofs-resource}

<dl class="resource"><dt>Path</dt><dd>/entry/{<a href="#entry-number-field">entry-number</a>}/proofs</dd></dt></dl>

A set of links to the [[#register-proof-resource]]s and [[#entry-proof-resource]]s which reference this entry.


# Archive resources # {#archive-resources}

## Download resource ## {#download}

<dl class="resource"><dt>Path</dt><dd>/download-register</dd></dt></dl>

The contents of an register MUST be made available as an archive.
The archive file MUST be capable of being used as backup of the register, with the exception of secrets used to generate [[#digital-proofs]].
The archive file SHOULD be made available in a single file, but MAY be split into multiple parts if it deemed too large.

The archive contains the following files in the following structure:

 * a directory with the name of the register containing
   * a file named "register.json" containing the [[#register-resource]] in the [[#json-representation]]
   * a file named "proof.json" containing one or more digital proofs for the register in the [[#json-representation]]
   * a directory named "item" containing all of the [[#item-resource]] in one or more parts in the [[#json-representation]]
   * a directory named "entry" containing all of the [[#entry-resource]] in one or more files in the [[#json-representation]]

A register archive MAY contain entry and item resources in the more space efficient [[#tsv-representation]].


# HTTP Headers # {#http-headers}

Table of link and other HTTP headers used by resources ..

  * [[RFC5988]]
  * <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">link-relations</a>
  * [[#immutable-resources]] SHOULD be served with a long-lived Cache-Control max-age value [[RFC7234]].
  * the [[#item-hash-field]] SHOULD be served as the etag header value for an [[#item-resource]].


<div class="example">
The following example shows the HTTP headers for the [[#json-representation]] of an immutable [[#item-resource]]:
<pre>
HTTP/1.1 200 OK
Date: Fri, 22 Jan 2016 08:00:08 GMT
Expires: Sun, 22 Jan 2017 08:00:08 GMT
Link: &lt;/school/12345/entries>; rel="version-history"
Content-Type: application/json
Content-Security-Policy: default-src 'self'
Cache-Control: no-transform, max-age=31536000
etag: c2f6fb7ed8332561f2252359b7d6f173a376a942
X-Xss-Protection "1; mode=block"
X-Frame-Options "SAMEORIGIN"
X-Content-Type-Options "nosniff"
Vary: Accept-Encoding
Content-Length: 522
</pre>
</div>


# Datatypes # {#datatypes}

## String datatype ## {#string-datatype}
  * [[UNICODE]] [[UTF-8]]

## Field-name datatype ## {#fieldname-datatype}

## Integer datatype ## {#integer-datatype}

<pre class='railroad'>
Choice:
  T: 0
  Sequence:
    Optional:
      T: -
    N: digit 1 to 9
    ZeroOrMore:
      N: digit 0 to 9
</pre>
All values are decimal. Leading zeros are not allowed, except for the integer '0', which is represented as the string “0”.
Negative values are marked with a leading “-” character ([[UNICODE]] 0x2D HYPHEN-MINUS).

<div class="example">
  The following examples are all valid integer values: 
  <pre>
    "100", "0", "-200"
  </pre>
</div>

## Datetime datatype ## {#datetime-datatype}

<pre class='railroad'>
T: YYYY
Optional:
  Sequence:
    T: -
    T: MM
    Optional:
      Sequence:
        T: -
        T: DD
        Optional:
          Sequence:
            T: T
            T: HH
            Optional:
              Sequence:
                T: :
                T: MM
                Optional:
                  Sequence:
                    T: :
                    T: SS
</pre>



  * Datetime values MUST be recorded as Universal Coordinated Time (UTC), and not local time such as British Summer Time (BST) or other offset from UTC.
  * Datetime values are all valid [[ISO8601]].
  * The may be taken as a consumer as an indication of the precision, in which case it is the responsibility of the consumer to decide how the date should be interpreted.

<div class="example">
  The following examples are all valid Datetime values: 
  <pre>
    "2001", "2001-01", "2001-01-31", "2001-01-31T23:20:55"
  </pre>
</div>

## Timestamp datatype ## {#timestamp-datatype}
<pre class='railroad'>
Sequence:
  T: YYYY
  T: -
  T: MM
  T: -
  T: DD
  T: T
  T: HH
  T: :
  T: MM
  T: :
  T: SS
  T: Z
</pre>

  * [[RFC3339]] timestamp, MUST be in UTC.

<div class="example">
  The following example is a valid Timestamp value: 
  <pre>
    "2001-01-31T23:20:55Z"
  </pre>
</div>


## Period datatype ## {#period-datatype}

<pre class='railroad'>
Choice:
  Sequence:
    N: start
    T: /
    N: end
  Sequence:
    N: start
    T: /
    N: duration
  Sequence:
    N: duration
    T: /
    N: end
  T: duration
</pre>

Where "start" and "end" are [[#datetime-datatype]] and "duration" is a
[[#duration-pattern]].

* Period values are all valid [[ISO8601]]
* When a Period value contains a datetime value it MUST follow the same
  principles described in [[#datetime-datatype]].

<div class="example">
  The following examples are all valid Period values:

  <pre>
    "2007-03-01T13:00:00Z/2008-05-11T15:30:00Z"
    "2007-03-01T13:00:00Z/P1Y2M10DT2H30M"
    "P1Y2M10DT2H30M/2008-05-11T15:30:00Z"
    "P1Y2M10DT2H30M"
  </pre>
</div>

### Duration pattern ### {#duration-pattern}

<pre class='railroad'>
T: P
OneOrMore:
  Stack:
    Sequence:
      Optional:
        Sequence:
          OneOrMore:
            N: 1-9
          T: Y
      Optional:
        Sequence:
          OneOrMore:
            N: 1-9
          T: M
      Optional:
        Sequence:
          OneOrMore:
            N: 1-9
          T: D
    Optional:
      Sequence:
        T: T
        Optional:
          Sequence:
            OneOrMore:
              N: 1-9
            T: H
        Optional:
          Sequence:
            OneOrMore:
              N: 1-9
            T: M
        Optional:
          Sequence:
            OneOrMore:
              N: 1-9
            T: S
        Optional:
          Sequence:
            T: Z
</pre>

Note that durations with atoms with a value of 0 MUST be removed. E.g.

* <code>P0Y1M</code> normalises to <code>P1M</code>.
* <code>PT0H1M0SZ</code> normalises to <code>PT1MZ</code>.

Also note that a duration MUST NOT be empty. These are invalid patterns: <code>P</code>,
<code>PT</code>.

This specification chooses not to allow any decimal points in the smallest
time atom.


## Point datatype ## {#point-datatype}
  * point [[GEOJSON]]

## Multipolygon datatype ## {#multipolygon-datatype}
  * multipolygon [[GEOJSON]]

## Text datatype ## {#text-datatype}
  * text [[MARKDOWN]]

## CURIE datatype ## {#curie-datatype}
Used to identify a record, possibly in another register.
  * curie [[CURIE]]

## Item-hash datatype ## {#item-hash-datatype}

A hash of the item's contents may be used to identify the contents of an item, irrespective of where it is stored or presented.

An item-hash is a hashing algorithm and a hash value, separated by a colon (:) character.  Currently there is only one valid hashing algorithm, <code>sha-256</code>.  In future, other alternative hashing algorithms may be added to this specification.  They will be distinguished by having a different string prefix.


### SHA-256 item hash ### {#sha-256-item-hash}

<div class="example">
The SHA-256 item hash of the item with a field <code>field1</code> with a value of <code>"a"</code> and a field <code>field2</code> with a value of <code>"b"</code> is:

<code>sha-256:129332749e67eb9ab7390d7da2e88173367d001ac3e9e39f06e41690cd05e3ae</code>
</div>

The <code>sha-256</code> item hash is computed by serialising the item to a canonical form of JSON, and computing the SHA-256 hash, defined in [[FIPS-180-4]], of the resulting serial form.

The canonicalisation algorithm is as follows:

 * JSON object values MUST be sorted into lexicographical order.  The
   keys of a JSON object must be a valid field name, which is
   restricted to the alphabet of lower case letters and hyphens, which
   makes this ordering relatively simple to implement.
 * All whitespace MUST be removed.
 * Characters in strings must be represented as follows:
   * For ASCII control characters (codepoints 0x00 - 0x1f):
     * If it has a short representation (<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, or <code>\t</code>), that short representation MUST be used.
     * Other control characters (such as NULL) MUST be represented as a <code>\u00XX</code> escape sequence.  Hexadecimal digits MUST be upper-case.
   * Backslash (<code>\</code>) and double quote (<code>"</code>) MUST be escaped as <code>\\</code> and <code>\"</code> respectively.
   * All other characters MUST be included literally (ie unescaped).  This includes forward-slash (<code>/</code>).

This canonicalisation algorithm is very similar to that used in [[JCS]], except that we stipulate an ordering of keys, and we enforce upper-case rather than lower-case hex digits.

ISSUE(openregister/specification#39): which hashing algorithms are allowed? where do we list them? how do we allow extensibility of hashing algorithm?

## Entry-reference datatype ## {#entry-reference-datatype}
Legal documents may need to cite an individual entry, rather than the latest entry of the record.

## URL datatype ## {#url-datatype}
Used to link to an external website, or other resource not held in a register.
  * URL [[URI]]


# Fields # {#fields}

<em>Fields defined by this specification</em>

## Primary key field ## {#primary-key-field}

For each register, there is a field called the <em>primary key
field</em>.  This field has the same name as the register itself: for
example, in the "school" register the primary key field is also called
"school".

## cardinality ## {#cardinality-field}

## domain ## {#domain-field}

## entry-number ## {#entry-number-field}

## index-entry-number ## {#index-entry-number-field}

## item-hash ## {#item-hash-field}

The item-hash field contains the [[#item-hash-datatype]] of an item.

## last-updated ## {#last-updated-field}

## field ## {#field-field}

## key ## {#key-field}


# Registers # {#registers}

## Register register ## {#register-register}

## Field register ## {#field-register}

## Datatype register ## {#datatype-register}




# Representations # {#representations}

Note: JSON and other representations can have a field which is missing. These have the same semantics as an empty field.

## HTML representation ## {#html-representation}
  * [[HTML5]]

## JSON representation ## {#json-representation}
  * suffix: .json
  * media-type: application/json
  * specification: [[JSON]] 

  All field values MUST be encoded as JSON strings. When JSON needs to be in a
  canonical format, use the procedure defined in [[#sha-256-item-hash]]

## YAML representation ## {#yaml-representation}

  * Suffix: .yaml
  * Content-Type: text/yaml;charset=UTF-8
  * Specification: [[YAML]] 

<div class="example">
The following example shows a [[#record-resource]] in the [[#yaml-representation]]:
<pre highlight="yaml">
entry:
  entry-number: "30568"
  timestamp: "2015-01-02T23:59:01Z"
  item-hash: "sha-256:87963123bd04263c878b36ad7ce421b8b68a07f9",
  key: "402175"
item:
  address: "100101030506"
  name: "Glanaman Home Tution Centre"
  school: "402175"
  start-date: "2007-11-07"
</pre>
</div>

ISSUE(openregister/specification#51): Which data types should we use from YAML?

## CSV representation ## {#csv-representation}
  * Suffix: .csv
  * Specification: [[tabular-data-model]]

## TSV representation ## {#tsv-representation}
  * Suffix: .tsv
  * Content-Type: text/tab-separated-values;charset=UTF-8
  * Specification: [[IANA-TSV]]


</pre>
</div>

## JSON-LD representation ## {#json-ld-representation}
  * [[JSON-LD]]

## Turtle representation ## {#ttl-representation}
  * Suffix: .ttl
  * Content-Type: text/turtle;charset=UTF-8
  * Specification: [[TURTLE]]

<div class="example">
The following example shows an [[#item-resource]] in the [[#ttl-representation]]:
<pre>
@prefix field: &lt;https://field.register.gov.uk/field/&gt;.

&lt;https://school.register.gov.uk/item/sha-256:af3056bd04263c878b36ad7ce421b8b68a0799&gt;
 field:address &lt;https://address.register.gov.uk/address/100101030506&gt; ;
 field:name "Glanaman Home Tution Centre" ;
 field:school &lt;https://school.register.gov.uk/record/402175&gt; ;
 field:start-date "2007-11-07" ;
</pre>
</div>

## Atom representation ## {#atom-representation}
  * [[RFC4287]]






# Digital Proofs # {#digital-proofs}

## Certificate transparency ## {#using-certificate-transparency}
  Certificate Transparency [[RFC6962]] is one of a number of possible methods of proving the integrity of a register.

### Entry hash ### {#entry-hash}

The entry hash is the application of a supported hashing algorithm on the data contained in the [[#entry-resource]]. The [[#item-hash-datatype]] of the entry, rather than the item itself ([[#item-resource]]), is part of the raw data hashed to create the entry hash.

The entry hash is required for many operations in Certificate Transparency.

### Signed tree head ### {#signed-tree-head}

The signed tree head for a register is the tree-head-signature property of the [[#register-proof-resource]], where the proof-identifier is specified as merkle:sha-256.

The signed tree head for a register is the signed Merkle tree root hash ([[RFC6962]] section 2.1) of a Merkle tree containing all entries in the register. The corresponding root-hash is also a property of the [[#register-proof-resource]].


### Verifying the register ### {#ct-verify-register}

To verify a register obtained from the [[#download]], a client must compute the Merkle tree root hash from the complete list of raw [[#entry-resource]], as per [[RFC6962]] section 2.1, ensuring that it equals the root-hash of the [[#register-proof-resource]] and that the same [[#signed-tree-head]] can be generated by signing the root-hash against a public key.

The client must also verify that for each [[#entry-resource]] in the register there exists an item with the corresponding [[#item-hash-datatype]] and that the contents of the item generate the correct [[#item-hash-datatype]].

### Verifying an entry ### {#ct-verify-entry}

The merkle-audit-path for the entry from the [[#entry-proof-resource]] provides the shortest list of additional nodes in the Merkle tree required to compute the Merkle tree root hash.

To verify an entry exists in a register, given that total-entries of the [[#entry-proof-resource]] equals the total-entries of the [[#register-proof-resource]], a client must combine the hash of the entry with each Merkle tree node in the merkle-audit-path consecutively, as per [[RFC6962]] section 2.1.1, and verify that the resulting Merkle tree root hash is equal to the root-hash of the [[#register-proof-resource]]. The client should also verify the [[#signed-tree-head]] against the computed root-hash using a public key.

### Verifying consistency ### {#ct-verify-consistency}

The merkle-consistency-nodes from the [[#consistency-proof-resource]] for two versions of a register provides the list of nodes in the Merkle tree required to verify that the first n entries (where n is the number of entries in the smaller register) are equal in both registers.

To verify the consistency of two versions of a register, given that total-entries-1 and total-entries-2 of the [[#consistency-proof-resource]] equal the total-entries of each [[#register-proof-resource]], the client must prove that the root-hash of the [[#register-proof-resource]] for the larger register can be computed using the set of consistency-proof-nodes and that the root-hash of the [[#register-proof-resource]] for the smaller register can be computed using a subset of the same consistency-proof-nodes, as per [[RFC6962]] section 2.1.2. The client must also verify the corresponding [[#signed-tree-head]] against each root-hash using a public key.

### Verifying the records ### {#ct-verify-records}

### Verifying a record ### {#ct-verify-record}

# Minting a new entry # {#minting}

  To mint a new entry in the register:
  * POST a new item in [[#json-representation]] to the ..mint url.. with the proposed new entry number.
  * The item will first appear as a new item in the store
  * <em> .. status codes and error cases </em>
  * <em> .. 202 Accepted with a Location header of the [[#entry-resource]] for the new entry</em>
  * The proposer can only trust it has been secured when the entry
    is listed in the [[#entries-resource]] with the same [[#entry-number-field]],
    and the [[#entry-resource]] is a covered by one or more [[#digital-proofs]] for the register.

The item MUST NOT contain empty fields.

# Redaction # {#redaction}

* An item may be removed from a register, but the entry MUST NOT be removed from the register.

ISSUE(openregister/specification#33): need a mechanism to mark a proof as deprecated.

ISSUE(openregister/specification#34): need a mechanism to terminate a proof and start a new proof.



# Versioning and extensibility # {#versioning-and-extensibility}

## Backwards compitability ## {#backwards-compatibility}
  * Semantics of a field cannot be significantly changed but not changed.

## Forwards compatibility ## {#forwards-compatibility}
  * Must-ignore rule.
  * Defaulting empty or missing values


## Points of extensibility ## {#extension-points}

### Fields ### {#extensibility-fields}
### Resources ### {#extensibility-resources}
### Proofs ### {#extensibility-proofs}
### Representations ### {#extensibility-representations}

A register may provide additional, possibly domain specific representations.

<div class="example">
A register containing fields with [[#point-datatype]] or [[#multipolygon-datatype]] values may also serve a list of items as [[GML]], [[KML]] or other geographical representation.
</div>

Additional representations for resources SHOULD be linked to from the HTML representation of the resource.

# Security considerations # {#security-considerations}

## Transport layer security ## {#transport-layer-security}

A register MUST only be available over HTTPS.  A register MUST NOT
make content available over insecure HTTP, though a register SHOULD
offer a redirect from HTTP to HTTPS.

A register contains authoritative data about a particular domain.  An
attacker in the middle should not be able to compromise the integrity
of the data in transit.  HTTPS is a basic control to prevent
intermediaries from being able to alter the data in transit.  For
people viewing a register via a web browser, HTTPS also prevents attackers
from injecting malicious content such as javascript.

### HTTP Strict Transport Security ### {#strict-transport-security}

A register SHOULD enable HTTP Strict Transport Security [[RFC6797]].

The <code>register.gov.uk</code> domain sets a
Strict-Transport-Security policy for all subdomains.  This means that
browsers which are aware of this policy will never attempt to use
insecure HTTP to any <code>*.register.gov.uk</code> domain.

### Content-Security-Policy ### {#content-security-policy}

A register SHOULD provide a Content-Security-Policy header [[CSP2]].
A basic Content-Security-Policy suitable for a register is:

<pre class="example">
Content-Security-Policy: default-src 'self'
</pre>

Note: if a register html view uses web assets (eg css or javascript)
from another domain, the header will need to be modified to whitelist
these assets.

## Mint access control ## {#mint-access-control}
## Compromised proof ## {#compromised-proof}
## Stale record ## {#stale-record}
## Denial of service ## {#denial-of-service}
## DNS ## {#DNS}
## Protecting the private key ## {#private-key}
## Compromised private key ## {#compromised-private-key}
## Hash clash ## {#hash-clash}


<pre class="link-defaults">
spec:html5; type:element; text:script
</pre>

<pre class="biblio">
{
  "RFC6962": {
      "href": "https://tools.ietf.org/html/rfc6962",
      "title": "Certificate Transparency",
      "publisher": "IETF",
      "authors": [ "B. Laurie", "A. Langley", "E. Kasper" ]
  },
  "GEOJSON": {
      "href": "https://tools.ietf.org/html/draft-ietf-geojson-00",
      "title": "The GeoJSON Format",
      "publisher": "IETF",
      "authors": [ "H. Butler", "M. Daly", "A. Doyle", "S. Gillies", "T. Schaub", "S. Hagen" ]
  },
  "MARKDOWN": {
      "href": "http://spec.commonmark.org/0.24/",
      "title": "Common Markdown",
      "publisher": "CommonMark",
      "authors": [ "John MacFarlane", "David Greenspan", "Vicent Marti", "Neil Williams", "Benjamin Dumke-von der Ehe", "Jeff Atwood" ]
  },
  "JCS": {
      "href": "https://cyberphone.github.io/doc/security/jcs.html",
      "title": "JSON Cleartext Signature",
      "publisher": "WebPKI",
      "authors": [ "Anders Rundgren" ]
  },
  "KML": {
      "href": "http://www.opengeospatial.org/standards/kml/",
      "title": "KML 2.3",
      "publisher": "OGC"
  }

}
</pre>

# Namespaces # {#namespaces}

* defined by this specification
* defined by {#core-registers}
